// system include files
#include <memory>
#include <utility>


// user include files
#include "FWCore/Framework/interface/EDAnalyzer.h"
#include "FWCore/Framework/interface/Event.h"
#include "FWCore/Framework/interface/MakerMacros.h"

#include "Geometry/CaloTopology/interface/EcalTrigTowerConstituentsMap.h"
#include "FWCore/Framework/interface/EventSetup.h"
#include "FWCore/Framework/interface/ESHandle.h"
#include "FWCore/ParameterSet/interface/ParameterSet.h"


#include "DataFormats/EcalDigi/interface/EcalDigiCollections.h"

#include "DataFormats/EcalRecHit/interface/EcalRecHit.h"
#include "DataFormats/EcalRecHit/interface/EcalRecHitCollections.h"

#include "Geometry/CaloGeometry/interface/CaloGeometry.h"
#include "Geometry/CaloGeometry/interface/CaloSubdetectorGeometry.h"
#include "Geometry/CaloGeometry/interface/CaloCellGeometry.h"
#include "Geometry/Records/interface/CaloGeometryRecord.h"

//#include "CalibCalorimetry/EcalTPGTools/interface/EcalEBTPGScale.h"
#include "CalibCalorimetry/EcalTPGTools/interface/EcalTPGScale.h"

#include "EcalEBTrigPrimAnalyzer.h"

#include <TMath.h>

using namespace edm;
class CaloSubdetectorGeometry;

EcalEBTrigPrimAnalyzer::EcalEBTrigPrimAnalyzer(const edm::ParameterSet&  iConfig)

{
  ecal_parts_.push_back("Barrel");
 

  recHits_= iConfig.getParameter<bool>("AnalyzeRecHits");
  debug_= iConfig.getParameter<bool>("Debug");
  //std::string  outputFilename= iConfig.getParameter<std::string>("OutputFile");
  rechits_labelEB_=consumes<EcalRecHitCollection>(iConfig.getParameter<edm::InputTag>("inputRecHitsEB"));
  primToken_=consumes<EcalEBTrigPrimDigiCollection>(iConfig.getParameter<edm::InputTag>("inputTP"));
  primCluToken_=consumes<EcalEBClusterTrigPrimDigiCollection>(iConfig.getParameter<edm::InputTag>("inputClusterTP"));
  tokenEBdigi_=consumes<EBDigiCollection>(iConfig.getParameter<edm::InputTag>("barrelEcalDigis"));
  pileupSummaryToken_=consumes<std::vector<PileupSummaryInfo> >(iConfig.getParameter<edm::InputTag>("bxInfos"));



  histfile_=new TFile("histos.root","RECREATE");
  //histfile_=new TFile(outputFilename,"RECREATE");
  tree_ = new TTree("TPGtree","TPGtree");
  tree_->Branch("tpIphi",&tpIphi_,"tpIphi/I");
  tree_->Branch("tpIeta",&tpIeta_,"tpIeta/I");
  tree_->Branch("rhIphi",&rhIphi_,"rhIphi/I");
  tree_->Branch("rhIeta",&rhIeta_,"rhIeta/I");
  tree_->Branch("eRec",&eRec_,"eRec/F");
  tree_->Branch("tpgADC",&tpgADC_,"tpgADC/I");
  tree_->Branch("tpgGeV",&tpgGeV_,"tpgGeV/F");
  tree_->Branch("ttf",&ttf_,"ttf/I");
  tree_->Branch("fg",&fg_,"fg/I");

  treeCl_ = new TTree("TPGClusterTree", "TPGClusterTree");
  treeCl_->Branch("nCl",&nCl_,"nCl_/I");
  treeCl_->Branch("nXtals",&nXtals_,"nXtals_/I");
  treeCl_->Branch("eCl",&eCl_,"eCl_/F");
  treeCl_->Branch("etClInADC",&etClInADC_,"etClInADC_/I");
  treeCl_->Branch("etClInGeV",&etClInGeV_,"etClInGeV_/F");
  treeCl_->Branch("etaCl",&etaCl_,"etaCl_/F");
  treeCl_->Branch("phiCl",&phiCl_,"phiCl_/F");
  treeCl_->Branch("s_eCl",&s_eCl_,"s_eCl_/F");
  treeCl_->Branch("s_etCl",&s_etCl_,"s_etCl_/F");
  treeCl_->Branch("s_etaCl",&s_etaCl_,"s_etaCl_/F");
  treeCl_->Branch("s_phiCl",&s_phiCl_,"s_phiCl_/F");
  treeCl_->Branch("etCluFromRH",&etCluFromRH_,"etCluFromRH_/F");

  for (unsigned int i=0;i<ecal_parts_.size();++i) {
    char title[30];
    sprintf(title,"%s_Et",ecal_parts_[i].c_str());
    ecal_et_[i]=new TH1I(title,"Et",255,0,255);
    sprintf(title,"%s_ttf",ecal_parts_[i].c_str());
    ecal_tt_[i]=new TH1I(title,"TTF",10,0,10);
    sprintf(title,"%s_fgvb",ecal_parts_[i].c_str());
    ecal_fgvb_[i]=new TH1I(title,"FGVB",10,0,10);
  }



  nEvents_=0;

  hTPvsTow_eta_= new TH2F("TP_vs_Tow_eta","TP vs Tow eta ; #eta(tow); #eta(tp)",50,-2.5,2.5,50,-2.5,2.5);
  hAllTPperEvt_ = new TH1F("AllTPperEvt","TP per Event; N_{TP};  ", 100, 0., 20000.);
  hTPperEvt_ = new TH1F("TPperEvt","N_{TP} per Event; N_{TP};  ", 100, 0., 20000.);
  hTP_iphiVsieta_= new TH2F("TP_iphiVsieta","TP i#phi vs i#eta ; i#eta(tp); i#phi(tp)",10,70,80,10,340,350);
  hTP_iphiVsieta_fullrange_= new TH2F("TP_iphiVsieta_fullrange","TP i#phi vs i#eta ; i#eta(tp); i#phi(tp)",200,-100,100,350,0,350);
  h_bxNumber_ = new TH1F ("bunchCrossing", "Bunch Crossing", 16, -12, 3);
  h_pu_ = new TH1F ("PU", "PU", 100 , 0, 300);
  //
  hCluTPperEvt_ = new TH1F("CluTPperEvt","N_{TP} per Event; N_{TP};  ", 100, 0., 500.);
  h_nXtals_ = new TH1F("nXtals","Number of xTals in the cluster; N_{xtals}; ",   20, -0.5, 19.5);
  h_etCluTP_ = new TH1F("etCluTP","E_{T}(tp);E_{T}(tp) (GeV);Count",100,0,50); 
  //

  h_nClu_[0] = new TH1F("nClu0","Number of Clusters with E_{T}>0 GeV; N_{Clu};N_{ev}", 100, 0., 500.);
  h_nClu_[1] = new TH1F("nClu05","Number of Cluster with E_{T}>0.5 GeV; N_{Clu};N_{ev}", 100, 0., 500.);
  h_nClu_[2] = new TH1F("nClu1","Number of Clusters with E_{T}>1 GeV; N_{Clu};N_{ev}", 100, 0., 500.);
  h_nClu_[3] = new TH1F("nClu2","Number of Clusters with E_{T}>2 GeV; N_{Clu};N_{ev}", 100, 0., 500.);
  h_nClu_[4] = new TH1F("nClu3","Number of Clusters with E_{T}>3 GeV; N_{Clu};N_{ev}", 100, 0., 500.);


  /*
  h_nClu_[0] = new TH1F("nClu0","Number of Clusters with E_{T}>0 GeV; N_{Clu};N_{ev}", 100, 0., 1000.);
  h_nClu_[1] = new TH1F("nClu05","Number of Cluster with E_{T}>0.5 GeV; N_{Clu};N_{ev}", 100, 0., 1000.);
  h_nClu_[2] = new TH1F("nClu1","Number of Clusters with E_{T}>1 GeV; N_{Clu};N_{ev}", 100, 0., 1000.);
  h_nClu_[3] = new TH1F("nClu2","Number of Clusters with E_{T}>2 GeV; N_{Clu};N_{ev}", 100, 0., 1000.);
  h_nClu_[4] = new TH1F("nClu3","Number of Clusters with E_{T}>3 GeV; N_{Clu};N_{ev}", 100, 0., 1000.);
  */
  /*
  h_nClu_[0] = new TH1F("nClu0","Number of Clusters with E_{T}>0 GeV; N_{Clu};N_{ev}",   10, -0.5, 9.5);
  h_nClu_[1] = new TH1F("nClu05","Number of Cluster with E_{T}>0.5 GeV; N_{Clu};N_{ev}", 10, -0.5, 9.5);
  h_nClu_[2] = new TH1F("nClu1","Number of Clusters with E_{T}>1 GeV; N_{Clu};N_{ev}",   10, -0.5, 9.5);
  h_nClu_[3] = new TH1F("nClu2","Number of Clusters with E_{T}>2 GeV; N_{Clu};N_{ev}",   10, -0.5, 9.5);
  h_nClu_[4] = new TH1F("nClu3","Number of Clusters with E_{T}>3 GeV; N_{Clu};N_{ev}",   10, -0.5, 9.5);
  */
  //


  if (recHits_) {
    hTPvsTow_ieta_= new TH2F("TP_vs_Tow_ieta","TP vs Tow ieta ; i#eta(tow); i#eta(tp)",200,-100,100,200,-100,100);

    hTPvsRechit_= new TH2F("TP_vs_RecHit","TP vs rechit Et;E_{T}(rh) (GeV);E_{T}(tp) (GeV)",100,-5,50,100,-5,50);
    hDeltaEt_ = new TH1F("DeltaEt","[Et(rh)-Et(TP)]/Et(rh); [E_{T}(rh)-E_{T}(tp)]/E_{T}(rh); Counts",200,-1,1);
    hTPoverRechit_= new TH1F("TP_over_RecHit","Et(TP/rechit); E_{T}(tp)/E_{T}(rh); Counts",200,0,2);
    hRechitEt_= new TH1F("RecHitEt","E_{T};E_{T}(rh) (GeV);Counts",100,0,50);
    hTPEt_= new TH1F("TPEt","E_{T}{tp);E_{T}(rh) (GeV);Count",100,0,50);
    hRatioEt_ = new TH1F("RatioTPoverRH","Et",100,0,50);
    hAllRechitEt_= new TH1F("AllRecHit","Et",100,0,50);

    hRH_iphiVsieta_= new TH2F("RH_iphiVsieta","RH i#phi vs i#eta ; i#eta(rh); i#phi(rh)",10,70,80,10,340,350);
    hRH_iphiVsieta_fullrange_= new TH2F("RH_iphiVsieta_fullrange","RH i#phi vs i#eta ; i#eta(rh); i#phi(rh)",200,-100,100,350,0,350);
    // cluster TP
    hCluTPoverRechit_= new TH1F("CluTP_over_RecHit","Et(CluTP/rechit); E_{T}(tp)/E_{T}(rh); Counts",200,0,2);
    hCluTPvsRechit_= new TH2F("CluTP_vs_RecHit","CluTP vs rechit Et;E_{T}(rh) (GeV);E_{T}(tp) (GeV)",100,-5,50,100,-5,50);

  }
}


EcalEBTrigPrimAnalyzer::~EcalEBTrigPrimAnalyzer()
{

   // do anything here that needs to be done at desctruction time
   // (e.g. close files, deallocate resources etc.)

  histfile_->Write();
  histfile_->Close();

}

void EcalEBTrigPrimAnalyzer::init(const edm::EventSetup & iSetup) {
  iSetup.get<IdealGeometryRecord>().get(eTTmap_);
  nTotTP_=0;   
}

//
// member functions
//

// ------------ method called to analyze the data  ------------
void
EcalEBTrigPrimAnalyzer::analyze(const edm::Event& iEvent, const  edm::EventSetup & iSetup)
{
  using namespace edm;
  using namespace std;
  nEvents_++;

  if ( nEvents_==1) this->init(iSetup);

  // Get input TP
  edm::Handle<EcalEBTrigPrimDigiCollection> tp;
  iEvent.getByToken(primToken_,tp);
  //
  edm::Handle<EcalEBClusterTrigPrimDigiCollection> tpClu;
  iEvent.getByToken(primCluToken_,tpClu);
  bool tpCluHandleIsValid=false;
  if ( tpClu.isValid() )
       tpCluHandleIsValid=true;


  //
  /*
  edm::Handle<EBDigiCollection> barrelDigiHandle;
  const EBDigiCollection *ebdigi=NULL;
  iEvent.getByToken(tokenEBdigi_,barrelDigiHandle);
  ebdigi=barrelDigiHandle.product();
  */
  // Get PUinfos
   edm::Handle<std::vector<PileupSummaryInfo> > puInfo;
   iEvent.getByToken(pileupSummaryToken_, puInfo);
   
  

  for (unsigned int i=0;i<tp.product()->size();i++) {
    EcalEBTriggerPrimitiveDigi d=(*(tp.product()))[i];
    int subdet=0;
    if (subdet==0) {
      ecal_et_[subdet]->Fill(d.encodedEt());
    }
  }


  //  if (!recHits_) return;



  edm::Handle<EcalRecHitCollection> rechit_EB_col;
  if ( recHits_ ) {
    // get the  RecHits
    iEvent.getByToken(rechits_labelEB_,rechit_EB_col);
  }

  edm::ESHandle<CaloSubdetectorGeometry> theBarrelGeometry_handle;
  iSetup.get<EcalBarrelGeometryRecord>().get("EcalBarrel",theBarrelGeometry_handle);
  const CaloSubdetectorGeometry *theBarrelGeometry;
  theBarrelGeometry = &(*theBarrelGeometry_handle);

  if (debug_) { std::cout << " TP analyzer  =================> Treating event  "<<iEvent.id()  <<  " Number of TPs " <<  tp.product()->size() <<  std::endl;
    if ( recHits_ ) std::cout << " Number of EB rechits "<<  rechit_EB_col.product()->size() << std::endl;
  }

  
  //std::cout << " PU info size " << puInfo->size() << std::endl;
  for (auto const& v : *puInfo) {
    int bx = v.getBunchCrossing();
    h_bxNumber_->Fill(float(bx));
    //std::cout << " bx " << bx << std::endl;
    if (bx == 0) 
      h_pu_->Fill(float(v.getPU_NumInteractions()));
  }


  hAllTPperEvt_->Fill(float(tp.product()->size())); 
  
  //if ( iEvent.id().event() != 648) return;

  //EcalEBTPGScale ecalScale ;
  EcalTPGScale ecalScale ;
  ecalScale.setEventSetup(iSetup) ;
  
  
  //  for(unsigned int iDigi = 0; iDigi < ebdigi->size() ; ++iDigi) {
  // EBDataFrame myFrame((*ebdigi)[iDigi]);  
  // const EBDetId & myId = myFrame.id();
     
  int nTP=0;  
  for (unsigned int i=0;i<tp.product()->size();i++) {
    EcalEBTriggerPrimitiveDigi d=(*(tp.product()))[i];
    const EBDetId TPid= d.id();
    // if ( myId != TPid ) continue;
    
    
    /*    
	  int index=getIndex(ebdigi,coarser);
	  std::cout << " Same xTal " << myId << " " << TPid << " coarser " << coarser << " index " << index << std::endl;
	  double Et = ecalScale.getTPGInGeV(d.encodedEt(), coarser) ; 
    */
    //this works if the energy is compressed into 8 bits float Et=d.compressedEt()/2.; // 2ADC counts/GeV
    float Et=d.encodedEt()/8.;    // 8 ADCcounts/GeV
    if ( Et<= 0 ) continue;
    nTP++;
    

    //    std::cout << " TP digi size " << d.size() << std::endl;
    for (int iBx=0;iBx<d.size();iBx++) {
      //std::cout << " TP samples " << d.sample(iBx) << std::endl; 

    }

    //      EcalTrigTowerDetId coarser=(*eTTmap_).towerOf(myId);
    // does not work float etaTow =  theBarrelGeometry->getGeometry(coarser)->getPosition().theta();
    // float etaTP =  theBarrelGeometry->getGeometry(TPid)->getPosition().eta();
    // does not work hTPvsTow_eta_->Fill ( etaTow,  etaTP );
    //      hTPvsTow_ieta_->Fill ( coarser.ieta(),  TPid.ieta() );
    
    
    tpIphi_ = TPid.iphi() ;
    tpIeta_ = TPid.ieta() ;
    tpgADC_ = d.encodedEt();
    tpgGeV_ = Et ;
    
    hTP_iphiVsieta_->Fill(TPid.ieta(), TPid.iphi(), Et);
    hTP_iphiVsieta_fullrange_->Fill(TPid.ieta(), TPid.iphi(), Et);
    
    
    if ( recHits_ ) {      
      for (unsigned int j=0;j<rechit_EB_col.product()->size();j++) {
	const EBDetId & myid1=(*rechit_EB_col.product())[j].id();
	float theta =  theBarrelGeometry->getGeometry(myid1)->getPosition().theta();
	float rhEt=((*rechit_EB_col.product())[j].energy())*sin(theta);
	if ( myid1 == TPid ) {
	  if (debug_) std::cout << " Analyzer same cristal " << myid1 << " " << TPid << std::endl;
	  //	  if ( rhEt < 1.5 && Et > 10 )  {
	  // std::cout << " TP analyzer  =================> Treating event  "<<iEvent.id()<< ", Number of EB rechits "<<  rechit_EB_col.product()->size() <<  " Number of TPs " <<  tp.product()->size() <<  std::endl;
	  //std::cout << " TP compressed et " << d.encodedEt()  << " Et in GeV  " <<  Et << " RH Et " << rhEt << " Et/rhEt " << Et/rhEt << std::endl;          
	  //} 
	  
	  //std::cout << " TP out " <<  d << std::endl;
	  
	  //	  for (int isam=0;isam< d.size();++isam) {
	  // std::cout << " d[isam].raw() "  <<  d[isam].raw() << std::endl;
	  //}
	  
	  rhIphi_ =  myid1.iphi() ;
	  rhIeta_ =  myid1.ieta() ;
	  hRH_iphiVsieta_->Fill(myid1.ieta(), myid1.iphi(), rhEt);
	  hRH_iphiVsieta_fullrange_->Fill(myid1.ieta(), myid1.iphi(), rhEt);
	  
	  hTPvsRechit_->Fill(rhEt,Et);
	  hTPoverRechit_->Fill(Et/rhEt);
	  hDeltaEt_ ->Fill ((rhEt-Et)/rhEt);
	  if (debug_) std::cout << " TP compressed et " << d.encodedEt()  << " Et in GeV  " <<  Et << " RH Et " << rhEt << " Et/rhEt " << Et/rhEt << std::endl;          
	  hRechitEt_->Fill(rhEt);
	  hTPEt_->Fill(Et);
	  if ( rhEt < 1000000) eRec_ = rhEt;

	}
	
      }  // end loop of recHits

    }  // if recHits
    tree_->Fill() ;    
  }   // end loop over TP collection
  
  //  } // end loop over digi collection

  hTPperEvt_->Fill(float(nTP));
  if ( nTP > 0 ) nTotTP_++;
  
  if ( recHits_) {  
    hRatioEt_->Divide( hTPEt_, hRechitEt_);
    for (unsigned int j=0;j<rechit_EB_col.product()->size();j++) {
      const EBDetId & myid1=(*rechit_EB_col.product())[j].id();
      float theta =  theBarrelGeometry->getGeometry(myid1)->getPosition().theta();
      float rhEt=((*rechit_EB_col.product())[j].energy())*sin(theta);
      if ( rhEt >0 ) 
	hAllRechitEt_ ->Fill(rhEt);
    }
  }

  // loop over cluster TP
  int nClu=0;
  int nClu_Etgt_05=0;
  int nClu_Etgt_1=0;
  int nClu_Etgt_2=0;
  int nClu_Etgt_3=0;



  if (tpCluHandleIsValid ) {
 
    nCl_ = tpClu.product()->size();
    int nCluTPPerEvt=0;
    for (unsigned int i=0;i<tpClu.product()->size();i++) {
      EcalEBClusterTriggerPrimitiveDigi d=(*(tpClu.product()))[i];
      const EBDetId TPid= d.id();
      float eta =  theBarrelGeometry->getGeometry(TPid)->getPosition().eta();
      float phi =  theBarrelGeometry->getGeometry(TPid)->getPosition().phi();
      nXtals_= d.crystalsInCluster().size();
      nCluTPPerEvt++;
      /*
      std::cout << " Number of xtals in clu " << nXtals_ << std::endl;
      std::cout << " List of IDs: " << std::endl;
      for  (int ii=0;ii<nXtals_;ii++) {
	std::cout <<  d.crystalsInCluster()[ii] << std::endl;
      }
      */


      etClInADC_ = d.encodedEt();
      etClInGeV_ = d.encodedEt()/8.;
      etaCl_ = d.eta();
      phiCl_ = d.phi();
      s_eCl_ = 0.;
      s_etCl_ = 0.;
      s_etaCl_ = eta;
      s_phiCl_ = phi;
      h_nXtals_->Fill(float(nXtals_));
      h_etCluTP_->Fill ( etClInGeV_);
 
      if (etClInGeV_>0)   nClu++;
      if (etClInGeV_>0.5) nClu_Etgt_05++;
      if (etClInGeV_>1) nClu_Etgt_1++;
      if (etClInGeV_>2) nClu_Etgt_2++;
      if (etClInGeV_>3) nClu_Etgt_3++;

      float Etsum=0;
      if ( recHits_ ) {    

	for  (int ii=0;ii<nXtals_;ii++) {
	  const EBDetId & xtalID =  d.crystalsInCluster()[ii];
	  
	  for (unsigned int j=0;j<rechit_EB_col.product()->size();j++) {
	    // check that the recHit correspond to the crystal in the cluster TP
	    const EBDetId & rhID=(*rechit_EB_col.product())[j].id();
	    float theta =  theBarrelGeometry->getGeometry(rhID)->getPosition().theta();
	    
	    if ( rhID == xtalID ) {
	      // std::cout << " RH id " << rhID << std::endl;
	      Etsum+=((*rechit_EB_col.product())[j].energy())*sin(theta);
	    }
	  }
	}
        // if rechits are available  
	hCluTPoverRechit_->Fill(etClInGeV_/Etsum);
	hCluTPvsRechit_->Fill(Etsum,etClInGeV_);
	etCluFromRH_= Etsum;	
      }
      treeCl_->Fill();    

    }
    std::cout << " nCluTPPerEvt " << nCluTPPerEvt << std::endl;
    hCluTPperEvt_ ->Fill(float(nCluTPPerEvt));

  }

  
  if ( nClu>0)         h_nClu_[0] ->Fill(float(nClu));
  if ( nClu_Etgt_05>0) h_nClu_[1] ->Fill(float(nClu_Etgt_05));
  if ( nClu_Etgt_1>0)  h_nClu_[2] ->Fill(float(nClu_Etgt_1));
  if ( nClu_Etgt_2>0)  h_nClu_[3] ->Fill(float(nClu_Etgt_2));
  if ( nClu_Etgt_3>0)  h_nClu_[4] ->Fill(float(nClu_Etgt_3));
  

  
  
}

void
EcalEBTrigPrimAnalyzer::endJob(){
  for (unsigned int i=0;i<ecal_parts_.size();++i) {
    ecal_et_[i]->Write();
    ecal_tt_[i]->Write();
    ecal_fgvb_[i]->Write();
  }

  h_bxNumber_->Write();
  h_pu_->Write();
  hAllTPperEvt_->Write();
  hTPperEvt_->Write();
  //
  for (int i=0; i<5; i++) h_nClu_[i] ->Write();

  hCluTPperEvt_->Write();
  h_nXtals_ ->Write();
  h_etCluTP_ ->Write();


  std::cout << " Total number of xtal TP " << nTotTP_ << std::endl;
  if (recHits_) {
    hTPvsTow_ieta_->Write();
    hTPvsTow_eta_->Write();    
    hTPvsRechit_->Write();
    hTPoverRechit_->Write();
    hAllRechitEt_->Write();
    hRechitEt_->Write();
    hDeltaEt_ ->Write();
    hTPEt_->Write();
    hRatioEt_->Write();
    hTP_iphiVsieta_->Write();
    hRH_iphiVsieta_->Write();
    hTP_iphiVsieta_fullrange_->Write();
    hRH_iphiVsieta_fullrange_->Write();
    hCluTPoverRechit_->Write();
    hCluTPvsRechit_->Write();
  }
}
  
